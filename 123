private HashMap<String, String> retrieveAndMapAlternatePartyIDs(
    RetrieveBusinessListResponse customerSearchResponse,
    SearchPartyLookupBusinessAggregationRequestPayload searchPartyLookupVO
) {

    ExecutorService executor = Executors.newFixedThreadPool(10); // limit concurrency
    List<CompletableFuture<Map.Entry<String, String>>> futures = customerSearchResponse.getBusiness().stream()
        .map(party -> CompletableFuture.supplyAsync(() -> {
            String alternatePartyKeyResponse = null;
            try {
                log.info("Calling alternate party API for {}", party.getFullName());
                alternatePartyKeyResponse = apiExecutor.makeGETRequest(
                    alternatePartyServiceUrl + "primaryPartyKey=" + party.getKey() +
                        "&partyKeyTypeCd=" + PartyLookupBusinessAggregationConstants.API_PARTY_TYPE_IPI,
                    (resp) -> {
                        if (resp.getStatusLine().getStatusCode() == 200) {
                            log.info("Successfully received alternate party key for {}", party.getFullName());
                            return EntityUtils.toString(resp.getEntity());
                        }
                        log.error("Failed to retrieve alternate party key for {}", party.getFullName());
                        return null;
                    });
            } catch (Exception e) {
                log.error("Error calling Party API for Alternate party key {}", e.getMessage());
            }

            if (alternatePartyKeyResponse == null) {
                return Map.entry(party.getKey(), null);
            } else {
                try {
                    String altKey = objectMapper
                        .readValue(alternatePartyKeyResponse, RetrieveAlternatePartyKeyResponse.class)
                        .getPartyToAlternateParty().get(0).getAlternateKey();
                    return Map.entry(party.getKey(), altKey);
                } catch (JsonProcessingException e) {
                    log.error("Error parsing alternate party key response {} for party {}",
                        alternatePartyKeyResponse, party.getFullName());
                    return Map.entry(party.getKey(), null);
                }
            }
        }, executor))
        .toList();

    // Wait for all to finish and collect results
    HashMap<String, String> result = futures.stream()
        .map(CompletableFuture::join)
        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (a, b) -> a, HashMap::new));

    executor.shutdown();
    return result;
}